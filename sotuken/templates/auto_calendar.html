<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>è‡ªå‹•ä½œæˆã‚·ãƒ•ãƒˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='auto_calendar.css') }}">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

</head>
<body>
  <header>è‡ªå‹•ä½œæˆã‚·ãƒ•ãƒˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼</header>

  {% if settings %}
  <div class="settings-box">
    <h3>ğŸ›  ç¾åœ¨ã®è‡ªå‹•ç”Ÿæˆè¨­å®š</h3>
    <ul>
      <li>é–‹å§‹æ™‚é–“: {{ settings.start_time }}</li>
      <li>çµ‚äº†æ™‚é–“: {{ settings.end_time }}</li>
      <li>ä¼‘æ†©æ™‚é–“: {{ settings.break_minutes }}åˆ†</li>
      <li>ã‚·ãƒ•ãƒˆé–“éš”: {{ settings.interval_minutes }}åˆ†</li>
      <li>æœ€å¤§å‹¤å‹™æ™‚é–“: {{ settings.max_hours_per_day }}æ™‚é–“</li>
      <li>æœ€å°å‹¤å‹™æ™‚é–“: {{ settings.min_hours_per_day }}æ™‚é–“</li>
      <li>æ™‚é–“å¸¯æœ€å¤§äººæ•°: {{ settings.max_people_per_shift }}</li>
      <li>ãƒ¢ãƒ¼ãƒ‰: {{ settings.auto_mode }}</li>
    </ul>
  </div>
  {% endif %}

  {% if message %}
    <p class="message">{{ message }}</p>
  {% endif %}

  {% if shifts %}
    <div id="charts"></div> <!-- ã‚°ãƒ©ãƒ•æç”»ã‚¨ãƒªã‚¢ -->
  {% else %}
    <p>ã‚·ãƒ•ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>
  {% endif %}

  <!-- ğŸ¯ ã“ã“ã‚’è¿½åŠ ï¼šãƒœã‚¿ãƒ³ç¾¤ -->
  <div class="button-group">
    <!-- âœ… å†ç·¨é›†ãƒœã‚¿ãƒ³ -->
  <a href="{{ url_for('makeshift.auto_calendar') }}" class="btn secondary">â™»ï¸ å†ç·¨é›†ï¼ˆå†ç”Ÿæˆï¼‰</a>
  </div>
  <div class="back">
    <button class="btn secondary" onclick="location.href='/makeshift/admin'">ğŸ”™ æˆ»ã‚‹</button>
  </div>

  <!-- Chart.js ã‚¹ã‚¯ãƒªãƒ—ãƒˆéƒ¨åˆ†ï¼ˆå¤‰æ›´ãªã—ï¼‰ -->
  <script>
    const shiftData = JSON.parse('{{ shifts|tojson|safe }}');
    console.log("âœ… shiftData:", shiftData);
    const validData = shiftData.filter(s => s.start_time && s.end_time);

    if (validData.length === 0) {
      document.getElementById("charts").innerHTML = "<p>æœ‰åŠ¹ãªã‚·ãƒ•ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>";
    } else {
      const grouped = {};
      validData.forEach(s => {
        if (!grouped[s.date]) grouped[s.date] = [];
        grouped[s.date].push(s);
      });
      const chartsDiv = document.getElementById("charts");
      Object.entries(grouped).forEach(([date, items], idx) => {
        const container = document.createElement("div");
        container.classList.add("chart-container");
        container.innerHTML = `<h2>${date}</h2><canvas id="chart_${idx}"></canvas>`;
        chartsDiv.appendChild(container);

        const ctx = document.getElementById(`chart_${idx}`).getContext("2d");
        const datasets = items.map((s, i) => {
          const start = new Date(`1970-01-01T${s.start_time}:00`);
          const end = new Date(`1970-01-01T${s.end_time}:00`);
          const isBreak = s.type === "break";
          const color = isBreak ? "rgba(255, 180, 80, 0.7)" : `hsl(${i * 70 % 360}, 70%, 60%)`;
          const label = isBreak ? `${s.user_id}ï¼ˆä¼‘æ†©ï¼‰` : s.user_id;

          return {
            label: label,
            data: [{ x: [start, end], y: s.user_id }],
            backgroundColor: color,
            borderColor: isBreak ? "rgba(255,140,0,1)" : "rgba(0,0,0,0.2)",
            borderWidth: 1,
          };
        });

        new Chart(ctx, {
          type: "bar",
          data: { datasets },
          options: {
            indexAxis: "y",
            responsive: true,
            scales: {
              x: {
                type: "time",
                time: { unit: "hour", displayFormats: { hour: "HH:mm" } },
                min: new Date("1970-01-01T00:00:00"),
                max: new Date("1970-01-01T23:59:00"),
                title: { display: true, text: "å‹¤å‹™æ™‚é–“" }
              },
              y: { title: { display: true, text: "ã‚¹ã‚¿ãƒƒãƒ•" } }
            },
            plugins: {
              legend: { display: true, position: "bottom" },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    const start = ctx.raw.x[0].toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                    const end = ctx.raw.x[1].toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                    return `${ctx.dataset.label}: ${start}ã€œ${end}`;
                  }
                }
              }
            }
          }
        });
      });
    }
  </script>
</body>
</html>
